<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>UML建模 | Hegra's world</title><meta name="author" content="Hegra"><meta name="copyright" content="Hegra"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一章 面向对象技术概述软件危机和软件工程控制软件系统复杂性的基本方法:(1)分解对于复杂的软件系统, 可以逐步将它分解成越来越小的组成部分, 直到不能再分解. 如Unix中的shell和管道就采用了分解思想. (2) 抽象当我们用抽象这个概念时, 我们承认正在考虑的问题是复杂的, 但我们并不打算理解问题的全部, 而只是选择解决其中的主要部分, 不去注意那些细节而已. 抽象又分为过程抽象和数据抽象">
<meta property="og:type" content="article">
<meta property="og:title" content="UML建模">
<meta property="og:url" content="http://blog.hegra.top/2023/03/04/UML%E5%BB%BA%E6%A8%A1/index.html">
<meta property="og:site_name" content="Hegra&#39;s world">
<meta property="og:description" content="第一章 面向对象技术概述软件危机和软件工程控制软件系统复杂性的基本方法:(1)分解对于复杂的软件系统, 可以逐步将它分解成越来越小的组成部分, 直到不能再分解. 如Unix中的shell和管道就采用了分解思想. (2) 抽象当我们用抽象这个概念时, 我们承认正在考虑的问题是复杂的, 但我们并不打算理解问题的全部, 而只是选择解决其中的主要部分, 不去注意那些细节而已. 抽象又分为过程抽象和数据抽象">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://edu-727.oss-cn-nanjing.aliyuncs.com/Other%20Pictures/ec43126fgy1hb0l7n507lj22dq1feu0x.jpg">
<meta property="article:published_time" content="2023-03-04T13:50:38.560Z">
<meta property="article:modified_time" content="2023-03-04T13:53:46.559Z">
<meta property="article:author" content="Hegra">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://edu-727.oss-cn-nanjing.aliyuncs.com/Other%20Pictures/ec43126fgy1hb0l7n507lj22dq1feu0x.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://blog.hegra.top/2023/03/04/UML%E5%BB%BA%E6%A8%A1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'UML建模',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-04 21:53:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://edu-727.oss-cn-nanjing.aliyuncs.com/%E7%BB%B4%E5%B0%BC.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://edu-727.oss-cn-nanjing.aliyuncs.com/Other%20Pictures/ec43126fgy1hb0l7n507lj22dq1feu0x.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hegra's world</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">UML建模</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-04T13:50:38.560Z" title="发表于 2023-03-04 21:50:38">2023-03-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-04T13:53:46.559Z" title="更新于 2023-03-04 21:53:46">2023-03-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>37分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="UML建模"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第一章-面向对象技术概述"><a href="#第一章-面向对象技术概述" class="headerlink" title="第一章 面向对象技术概述"></a>第一章 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1&spm=1001.2101.3001.7020">面向对象</a>技术概述</h1><h2 id="软件危机和软件工程"><a href="#软件危机和软件工程" class="headerlink" title="软件危机和软件工程"></a>软件危机和软件工程</h2><h3 id="控制软件系统复杂性的基本方法"><a href="#控制软件系统复杂性的基本方法" class="headerlink" title="控制软件系统复杂性的基本方法:"></a>控制软件系统复杂性的基本方法:</h3><h4 id="1-分解"><a href="#1-分解" class="headerlink" title="(1)分解"></a>(1)分解</h4><p>对于复杂的软件系统, 可以逐步将它分解成越来越小的组成部分, 直到不能再分解. 如Unix中的shell和管道就采用了分解思想.</p>
<h4 id="2-抽象"><a href="#2-抽象" class="headerlink" title="(2) 抽象"></a>(2) 抽象</h4><p>当我们用抽象这个概念时, 我们承认正在考虑的问题是复杂的, 但我们并不打算理解问题的全部, 而只是选择解决其中的主要部分, 不去注意那些细节而已.</p>
<p>抽象又分为过程抽象和数据抽象(数据类型)</p>
<p>在面向对象兴起之前, 编程以过程为中心, 例如结构化设计方法. 然而, 系统已经达到了超越其处理能力的复杂性极点. 有了对象, 我们能够提升抽象级别来构建更大的, 更复杂的系统.</p>
<h4 id="3-模块化"><a href="#3-模块化" class="headerlink" title="(3) 模块化"></a>(3) 模块化</h4><p>高内聚, 低耦合. 高内聚指的是在一个模块中应尽量多地汇集逻辑上相关的计算资源; 低耦合指的模块之间的相互作用尽可能地少</p>
<h4 id="4-信息隐蔽"><a href="#4-信息隐蔽" class="headerlink" title="(4)信息隐蔽"></a>(4)信息隐蔽</h4><p>信息隐蔽也称封装, 把模块内的实现细节与外界隔离, 用户只需知道模块的功能, 而不需要了解模块内部细节.</p>
<p>在结构化方法中, 现实世界被映射为功能的集合. 在面向对象方法中, 现实中的实体及其相互关系被映射为对象及对象之间的关系.</p>
<h3 id="对象和实例"><a href="#对象和实例" class="headerlink" title="对象和实例"></a>对象和实例</h3><p>对象(object)中系统中用来描述客观事物的一个实体, 它是构成系统的基本单位. 一个对象由一组属性和操作这组属性的一组方法组成.</p>
<p>对象之间通过消息通信, 一个对象向另一个对象发送消息激活某个功能.</p>
<p>实例(instance)的概念和对象类似, 实例的含义更加广泛, 不仅对类, 其他建模元素也有实例. 如类的实例就是对象, 而关联的实例就是链</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类是具有相同属性和方法的一组对象的集合,(比如:实例类) 它为属于该类的全部对象提供了统一的抽象描述. 同一个类的对象具有相同的属性和方法, 这里是指它们的定义形式相同, 而不是说每个对象的属性相同.</p>
<p>类是静态的, 类的语义和类之间的关系在程序执行前就已经定义完毕, 而对象是动态的, 对象是程序执行时被创建或删除的.</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装(encapsulation)就是把对象的属性和方法结合成一个独立的单位, 并尽可能地隐藏对象内部细节</p>
<p>封装使对象成为两个部分: 接口和实现部分, 对于用户来说, 接口是可见的, 而实现的部分是不可见的.</p>
<p>封装提供了两种保护. 1是可以保护对象, 防止用户直接访问对象的内部细节.</p>
<p> 2是可以保护客户端, 以防对象实现部分的变化产生副作用, 即实现部分的改变不会影响到相应客户</p>
<p> 端的改变</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承就是子类可以继承父类的属性或方法.</p>
<p>继承好处: 1增加了软件重用的机会, 可以降低软件开发和维护的费用. 2. 可以保证类的一致性, 父类可以为所有子类定制规则, 子类必须遵守这些规则.</p>
<p>如:c++的虚函数, java的接口等.</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>在面向对象的技术中, 多态指的是一个实体拥有在不同上下文条件下具有不同的意义或用法的能力</p>
<p>多态往往和覆盖, 绑定等概念结合使用.多态是保证系统具有良好的适应性的重要手段之一.</p>
<h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>消息(message)就是面向对象发出的服务请求. 它包含了提供服务的对象标识, 方法标识, 输入信息和回答信息等.</p>
<p>消息: 包括同步消息和异步消息. 如果消息是异步的, 则一个对象发送消息后就继续自己的活动, 不等待消息接收者返回结果. 而函数往往是同步的, 函数调用者要等待接收者返回结果.</p>
<h1 id="第二章-UML概述"><a href="#第二章-UML概述" class="headerlink" title="第二章 UML概述"></a>第二章 UML概述</h1><h3 id="UML的构成"><a href="#UML的构成" class="headerlink" title="UML的构成"></a>UML的构成</h3><h4 id="1-基本构造块"><a href="#1-基本构造块" class="headerlink" title="1. 基本构造块:"></a>1. 基本构造块:</h4><h5 id="关系-依赖dependency-关联association-泛化generalization-实现realization"><a href="#关系-依赖dependency-关联association-泛化generalization-实现realization" class="headerlink" title="关系(依赖dependency, 关联association, 泛化generalization, 实现realization)"></a>关系(依赖dependency, 关联association, 泛化generalization, 实现realization)</h5><h5 id="图-diagram"><a href="#图-diagram" class="headerlink" title="图(diagram)"></a>图(diagram)</h5><h5 id="事物-thing"><a href="#事物-thing" class="headerlink" title="事物(thing):"></a>事物(thing):</h5><p> (1). 结构事物(structural thing):类(class), 接口(interface), 协作(collaboration), 用例(use case), 主动类(action</p>
<p> class), 构件(component) 和节点(node)</p>
<p> (2). 行为事物(behavioral thing): 交互(interaction) 和 状态机(state machine)</p>
<p> (3). 分组事物(grouping thing): 包(package)</p>
<p> (4). 注释事物(annotational thing): uml中的注解</p>
<h4 id="2-规则-rule"><a href="#2-规则-rule" class="headerlink" title="2. 规则(rule)"></a>2. 规则(rule)</h4><h4 id="3-公共机制-common-mechanism"><a href="#3-公共机制-common-mechanism" class="headerlink" title="3. 公共机制(common mechanism)"></a>3. 公共机制(common mechanism)</h4><h4 id="4-五个语义规则"><a href="#4-五个语义规则" class="headerlink" title="4. 五个语义规则"></a>4. 五个语义规则</h4><p>命名, 范围, 可见性, 完整性, 执行</p>
<h4 id="5-通用机制"><a href="#5-通用机制" class="headerlink" title="5.通用机制:"></a>5.通用机制:</h4><p>1规范说明,</p>
<p>2.修饰</p>
<p>3.通用划分,</p>
<p>4.扩展机制, 其中扩展机制包括版型, 标记值, 约束</p>
<h3 id="UML的视图"><a href="#UML的视图" class="headerlink" title="UML的视图"></a>UML的视图</h3><p>UMl中的视图:</p>
<p>用例视图: 表示系统的功能性需求</p>
<p>逻辑视图: 表示系统的概念设计和子系统结构等</p>
<p>实现视图: 说明代码的结构</p>
<p>进程视图: 说明系统中的并发执行和同步情况</p>
<p>部署图: 用于定义硬件节点的物理结构</p>
<h3 id="UMl的应用领域"><a href="#UMl的应用领域" class="headerlink" title="UMl的应用领域"></a>UMl的应用领域</h3><p>软件开发, 金融… 范围极大</p>
<p>UML的应用示例</p>
<h1 id="第三章-用例图-建模的开始"><a href="#第三章-用例图-建模的开始" class="headerlink" title="第三章 用例图: 建模的开始"></a>第三章 用例图: 建模的开始</h1><h2 id="什么是建模"><a href="#什么是建模" class="headerlink" title="什么是建模"></a>什么是建模</h2><ol>
<li>选择一个角度, 对现实进行抽象. 比如, 美式咖啡和拿铁咖啡, 对这二者进行抽象, 就得到它们的父类: 咖啡类</li>
<li>在统一过程中, 一个用例就是一个分析单元 , 设计单元, 开发单元, 测试单元, 甚至是部署单元.</li>
</ol>
<h2 id="用例图基本概念"><a href="#用例图基本概念" class="headerlink" title="用例图基本概念"></a>用例图基本概念</h2><ol>
<li>用例图与协作图, 顺序图, 活动图共同组成了用例视图</li>
<li>用例图是需求分析的第一步, 用例图用来描述系统的功能需求集合</li>
<li>在uml中, 用例图用椭圆来表示.</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/2fe04577b3c04a4ca675cdd3df9c6fe9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<h4 id="参与者的概念"><a href="#参与者的概念" class="headerlink" title="参与者的概念"></a>参与者的概念</h4><p>参与者是指系统以外的, 需要使用系统或与系统交互的事物, 包括人, 设备, 外部系统等.</p>
<p>例如:</p>
<p>1.银行业务系统中可能的参与者: 客户 管理人员 厂商 Mail系统</p>
<p>2.教务管理系统可能的参与者: 学生 教师 管理员</p>
<p>案例: 你要寄信, 把信交给了邮局工作人员. 这时, 你是参与者, 工作人员不是参与者, 而是业务工人.</p>
<h4 id="寻找和确定参与者"><a href="#寻找和确定参与者" class="headerlink" title="寻找和确定参与者"></a>寻找和确定参与者</h4><p>建模是从寻找抽象角度开始的, 那么, 定义参与者就是我们寻找抽象的开始, 参与者在建模中处于核心地位</p>
<p>为找出参与者, 我们需要问两个问题:</p>
<p>1.谁对系统有着明确的目标和要求并且主动发出动作?</p>
<p>2.系统为谁服务?</p>
<p>例如: 小王去银行开户, 向大厅经理询问了办理流程, 填写了表单并交给柜台职员, 最后拿到银行存折.</p>
<p>在这个案例中, 小王是参与者, 大厅经理和柜台职员是业务工人.</p>
<h4 id="检查点"><a href="#检查点" class="headerlink" title="检查点"></a>检查点</h4><p>需要问两个问题:</p>
<ol>
<li>是否找到所有参与者?</li>
<li>每个参与者是否至少涉及一个用例?</li>
</ol>
<p>例如, 在自动饮料售货机中, 有三个参与者</p>
<p><img src="https://img-blog.csdnimg.cn/4f1b6ba61da24021a0e03eb786b35e98.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<h4 id="参与者之间的关系"><a href="#参与者之间的关系" class="headerlink" title="参与者之间的关系"></a>参与者之间的关系</h4><p>由于参与者事实上就是类, 因此, 参与者之间也有继承关系(泛化).</p>
<p>参与者之间的泛化关系表示父参与者与子参与者之间的联系. 子参与者不仅可以继承父参与者的行为和含义, 还可以增加自己独有的行为和含义.</p>
<p>泛化关系用带三角箭头的实心表示.</p>
<p>例如:<br><img src="https://img-blog.csdnimg.cn/8bd5021cf22d4849b82acec9c564fb92.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h4><p>定义: 用例是系统, 子系统或类 和 外部的参与者交互的动作序列的说明, 包括可选的动作序列和会出现异常的动作序列</p>
<p>在uml中, 用例用一个椭圆表示, 用例往往用动宾结构或主谓结构命名</p>
<p>采用用例进行需求分析有如下特点:</p>
<p>1.用例从使用系统的角度描述系统中的信息</p>
<p>2.用例描述了用户提出的一些可见的需求</p>
<p>3.用例是对系统行为的动态描述</p>
<p>用例是有条件的, 如做饭的例子:</p>
<p>要做饭, 首先得有米, 这是启动用例的前提, 也称为前置条件; 用例执行完成后, 会得到一个结果: 米变成了饭, 这称为后置条件.</p>
<p>完整的用例定义由参与者, 前置条件, 场景, 后置条件构成.</p>
<h2 id="3-6-用例分析"><a href="#3-6-用例分析" class="headerlink" title="3.6 用例分析"></a>3.6 用例分析</h2><p>判断用例是否准确的依据:</p>
<p>1.用例是相对独立的. (这意味着不需要其他用例交互就可以独自完成参与者的目的. 如取钱是用例, 而填取款单不是)</p>
<p>2.用例的执行结果对参与者来说是可观测且有意义的. (如登陆系统是一个有效用例, 但输入密码不是)</p>
<p>3.用例必须由一个参与者发起(不存在没有参与者的用例, 用例也不应该自启动和主动启动另一个用例, 如从ATM取钱是用例,</p>
<p>而ATM吐钞不是)</p>
<p>4.用例通常是以动宾短语形式出现的.(如喝水 而”喝”和水不是)</p>
<p>5.用例就是一个需求单元, 分析单元, 设计单元, 开发单元, 测试单元, 甚至是部署单元, 一旦确定了用例, 软件开发工作的其他</p>
<p>活动都就以这个用例为基础, 围绕着它进行.</p>
<h4 id="用例的粒度"><a href="#用例的粒度" class="headerlink" title="用例的粒度"></a>用例的粒度</h4><p>在用例分析阶段,(概念建模阶段), 用例以能描述一项完整的业务流程为宜. 如取钱, 借书等, 但不要细到验证密码, 查找书上等单个步骤.</p>
<p>在系统分析阶段, 用例的视角是针对计算机的, 粒度以一个用例可以描述操作者与计算机的一次完整交互为宜. 如(填写申请单, 审核申请单…). 另一个要参考的粒度是一个用例的开发工作量在一周左右为宜.</p>
<p>在业务用例阶段, 最标准的方法是, 以该用例是否完成了参与者的某个完整的目的为依据. (如借书是用例, 而查询书目, 查询记录等只是完成这个目的的过程)</p>
<p>原则: 在同一个需求阶段, 所有用例的粒度应该是同一个量级.</p>
<h4 id="用例的获取"><a href="#用例的获取" class="headerlink" title="用例的获取"></a>用例的获取</h4><p>需要清楚下面几个问题</p>
<p>1.参与者是位于系统边界之外的</p>
<p>2.参与者对系统有着明确的期望和回报等要求</p>
<p>3.参与者的期望和回报要求在系统边界之内</p>
<p>将每个有效的期望借助用例绘制出并命名就完成了用例获取的工作</p>
<h4 id="目标和步骤的误区"><a href="#目标和步骤的误区" class="headerlink" title="目标和步骤的误区"></a>目标和步骤的误区</h4><p>在使用中, 对用例使用的另一个误区是: 混淆目标与完成目标的步骤.</p>
<p>一个用例是参与者对目标系统的一个愿望, 一个完整的事件. 为了完成这个事件需要经过很多步骤, 但这些步骤不能够完整地</p>
<p>反映参与者的目标, 不能作为用例</p>
<p>如寄信和付钱, 两个用例粒度不同, 边界不同, 它们显然不应该同时出现在一个视图里.</p>
<h4 id="用例粒度的误区"><a href="#用例粒度的误区" class="headerlink" title="用例粒度的误区"></a>用例粒度的误区</h4><p>产生用例粒度错误的原因首先是: 未分清目标和步骤</p>
<p>如系统管理管理网站和修改订单, 显然, 显然管理网站的粒度比修改订单的大.</p>
<p>在同一个需求阶段, 必须保持所有用例的粒度都在同一量级</p>
<h4 id="业务用例"><a href="#业务用例" class="headerlink" title="业务用例"></a>业务用例</h4><p>业务用例是用例版型中的一种, 专门用于需求阶段的业务建模</p>
<p>站在业务参与者的角度看到的将是业务边界而非系统边界</p>
<h4 id="业务用例实现"><a href="#业务用例实现" class="headerlink" title="业务用例实现"></a>业务用例实现</h4><p>业务用例实现, 也称业务用例实例, 是用例版型中的一种, 专门用于需求阶段的业务建模.</p>
<p>业务用例实现是业务用例的一种实现方式, 好比接口和实现类</p>
<p>业务用例实现的意义在于它表达了同一项业务的不同实现方式</p>
<p>如缴纳话费的三种实现方式: 营业厅缴费, 银行缴费, 预存话费</p>
<h4 id="系统用例"><a href="#系统用例" class="headerlink" title="系统用例"></a>系统用例</h4><p>系统用例是用来定义系统范围, 获取功能性需要的. 如果不是特别强调, 读者可以把用例等同于系统用例</p>
<h4 id="用例实现"><a href="#用例实现" class="headerlink" title="用例实现"></a>用例实现</h4><p>用例实现完整的叫法是系统用例的实现, 一个用例实现代表用例的一种实现方式</p>
<h2 id="3-7-用例之间的关系"><a href="#3-7-用例之间的关系" class="headerlink" title="3.7 用例之间的关系"></a>3.7 用例之间的关系</h2><p>用例除了参与者之间有关联关系, 用例之间也存在着一定的关系, 如泛化关系, 包含关系, 扩展关系等.</p>
<p>也可以用UML的扩展机制自定义用例之间的关系</p>
<h3 id="泛化关系-generalization"><a href="#泛化关系-generalization" class="headerlink" title="泛化关系(generalization)"></a>泛化关系(generalization)</h3><p>在程序设计语言中, 与”继承”这个概念相似</p>
<p>在泛化关系中, 子用例继承了父用例的行为和含义, 子用例也可以增加新的行为和含义或者覆盖父用例的行为和含义</p>
<p><img src="https://img-blog.csdnimg.cn/45bd397d54164ae8af500ed941745f81.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="包含关系-include"><a href="#包含关系-include" class="headerlink" title="包含关系(include)"></a>包含关系(include)</h3><p>包含关系指的两个用例之间的关系, 其中一个用例(称作基本用例)的行为包含了另一个用例(称作包含用例)的行为</p>
<p>包含关系是依赖关系的版型</p>
<p><img src="https://img-blog.csdnimg.cn/e8470dd9687740168687e287f30e8fe2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="扩展关系-extend"><a href="#扩展关系-extend" class="headerlink" title="扩展关系(extend)"></a>扩展关系(extend)</h3><p>扩展关系基基本含义与包含关系类似, 也是依赖关系的版型, 也就是说扩展关系是特殊的依赖关系, 通常表示基本用例在特定情况下会用到扩展用例</p>
<p>与包含关系不同的是, 扩展关系的箭头指向是从扩展用例到基本用例</p>
<p><img src="https://img-blog.csdnimg.cn/9474d3febce14a8eaeec99a2dc4af76f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="用例的泛化-包含-扩展关系的比较"><a href="#用例的泛化-包含-扩展关系的比较" class="headerlink" title="用例的泛化, 包含, 扩展关系的比较"></a>用例的泛化, 包含, 扩展关系的比较</h3><p>包含关系: 在执行基本用例时, 一定会执行包含用例部分</p>
<p>扩展关系: 在执行基本用例时, 只有满足扩展点的要求时才执行扩展用例</p>
<p>关联(association): 参与者和用例之间的关系</p>
<p>泛化(generalization): 参与者之间或用例之间的关系</p>
<p>包含(include): 用例之间的关系</p>
<p>扩展(extend): 用例之间的关系</p>
<p>关联关系是两个或多个类元之间的关系. 这里所说的类元是一种建模元素, 常见的类元包括类, 参与者, 组件, 数据类型, 接口, 节点, 信号, 子系统, 用例等, 其中类是最常见的类元</p>
<p>泛化关系是两个类元之间的关系</p>
<p>依赖关系表示的是两个元素或元素集之间的一种关系</p>
<p>包含关系和扩展关系都属于依赖关系</p>
<h2 id="3-8-用例图"><a href="#3-8-用例图" class="headerlink" title="3.8 用例图"></a>3.8 用例图</h2><p>用例图是一组用例, 参与者以及它们之间的关系的图</p>
<p>如金融贸易系统用例图</p>
<p><img src="https://img-blog.csdnimg.cn/a9f59460b76b47be9fc4f140950fa3c7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="3-9-用例的描述"><a href="#3-9-用例的描述" class="headerlink" title="3.9 用例的描述"></a>3.9 用例的描述</h2><p>事实上, 用例描述才是用例的主体部分</p>
<p>用例的描述一般应包括以下内容:</p>
<ol>
<li>用例的目标</li>
<li>用例是怎么启动的</li>
<li>参与者和用例之间的消息是如何传送</li>
<li>用例除了主路径之外, 其它路径是什么</li>
<li>用例结束后的系统状态</li>
<li>其它需要描述的内容</li>
</ol>
<p>总之, 描述用例的原则是尽可能写得充分</p>
<p>用例模板(略)</p>
<p>初学者在描述用例时易犯的错误:</p>
<ol>
<li>只描述系统的行为, 没有描述参与者的行为</li>
<li>只描述参与者的行为, 没有描述系统的行为</li>
<li>描述冗长</li>
</ol>
<p>在描述用例时, 可以采用更为简洁的描述方式, 如合并数据项, 提供抽象的高层描述</p>
<p>正确的用例描述</p>
<p>Use Case: 购买东西</p>
<ol>
<li>顾客使用ID和密码进入系统</li>
<li>系统验证顾客身份</li>
<li>顾客提供个人信息(姓名, 地址, 电话), 并选择购买的商品及数量</li>
<li>系统验证顾客是否为老顾客</li>
<li>系统使用库存系统验证要购买的商品数量是否少于库存量</li>
<li>…(省略)</li>
</ol>
<h2 id="3-10-寻找用例的方法"><a href="#3-10-寻找用例的方法" class="headerlink" title="3.10 寻找用例的方法"></a>3.10 寻找用例的方法</h2><p>用例分析的步骤:</p>
<ol>
<li>找出系统外部的参与者和外部系统, 确定系统的边界和范围</li>
<li>确定每一个参与者所期望的行为</li>
<li>把这些系统行为命名为用例</li>
<li>使用包含, 泛化, 扩展等关系处理系统行为的公共或变更部分</li>
<li>编制每一个用例的脚本</li>
<li>绘制用例图</li>
<li>区分主事件流和异常事件流, 如果有需要, 可以把异常事件流当作单独用例来处理</li>
<li>细化用例图, 解决用例间的重复与冲突问题</li>
</ol>
<h2 id="3-11-建模实例"><a href="#3-11-建模实例" class="headerlink" title="3.11 建模实例"></a>3.11 建模实例</h2><p>我校打算开发一个网上选课系统, 需求如下:</p>
<p>管理员通过系统管理界面验证身份进入系统, 建立本学期要开设的各种课程, 将课程信息保存在数据库中并可以对系统进行修改和删除. 学生通过客户机根据学号和密码进入选课界面, 在这里学生可以进行两种操作: 查询已选课程, 选课. 同样, 通过业务层, 这些操作会存入数据库中. 数据库部署在服务器上, 通过一个开放的sql接口操作数据库</p>
<p>确定参与者: 管理员, 学生, 数据库代理</p>
<p>识别用例:</p>
<ol>
<li>学生: 用户登录 查询已选课程 选课 付费</li>
<li>管理员: 用户登录 增加课程 修改课程 删除课程</li>
<li>数据库代理: 所有和数据库操作相关的用例</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/198c2a87944a44529c1f6fa3f0fbf245.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>Add course的用例描述:</p>
<p><img src="https://img-blog.csdnimg.cn/b606d3a3ce11472f89e326f82d85903d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/a8a1dbb0c3e44eaeadc4ad601a0f116e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="第四章-状态图和活动图"><a href="#第四章-状态图和活动图" class="headerlink" title="第四章 状态图和活动图"></a>第四章 状态图和活动图</h1><h2 id="4-1什么是状态图"><a href="#4-1什么是状态图" class="headerlink" title="4.1什么是状态图"></a>4.1什么是状态图</h2><ol>
<li>状态图(statechart diagram)主要用来描述描述一个对象在其生存期间的动态行为, 表现一个对象所经历的状态序列, 引起状态转移的事件(event), 以及因状态转移而伴随发生的动作(action)</li>
<li>一般可以状态机对一个对象 (这里的对象可以是类的实例, 用例的实例或整个系统的实例) 的生命周期建模</li>
<li>状态图是用于显示状态机的, 重点在于描述状态之间的控制流</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/799db3d11c6f427187ae955472641c50.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<ol>
<li>在状态机中, 动作既可以与状态相关也可以与转移相关. 如果动作是状态相关, 则对象在进入一个状态将触发某一动作, 而不管是从哪个状态进入这个状态的. 如果动作是与转移相关的, 则对象在不同的状态转移时, 将触发相应的动作</li>
<li>Moore机: 所有的动作都与状态有关; Mealy机: 所有的动作都与转移有关.</li>
</ol>
<h2 id="4-2-状态图的基本概念"><a href="#4-2-状态图的基本概念" class="headerlink" title="4.2 状态图的基本概念"></a>4.2 状态图的基本概念</h2><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><ol>
<li>状态(state)是指对象的生命周期中的某个条件或状况, 在此期间对象将满足某些条件, 执行某些活动或等待某些事件.</li>
<li>所有对象都有状态,状态是对象执行一项或多项活动的结果, 当某个事件发生后, 对象的状态将发生变化</li>
<li>状态可以细分为不同的类型, 如初态, 终态, 中间状态, 组合状态, 历史状态等. 一个状态图只有一个初态, 但但终态可以有一个或多个, 也可以没有终态</li>
<li>中间状态包括两个区域: 名字域和内部转移域</li>
</ol>
<h3 id="组合状态和子状态"><a href="#组合状态和子状态" class="headerlink" title="组合状态和子状态"></a>组合状态和子状态</h3><p>嵌套在另一个状态的状态称作子状态(substate), 含有子状态的状态称作组合状态(composite state).</p>
<p>如图W是组合状态, E和F是子状态</p>
<p><img src="https://img-blog.csdnimg.cn/ad897d3d22de49bc9e35b597c4cc6cdc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>子状态可以分为or关系和and关系</p>
<ol>
<li>or关系: 在某一时刻可到达一个子状态</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/eb9d2945239240eca582135cf3035f91.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<ol>
<li>and关系: 组合状态中在某一时刻可同时到达多个子状态</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/3cc94a1d36514c0ba7e3782138e792f7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="历史状态"><a href="#历史状态" class="headerlink" title="历史状态"></a>历史状态</h3><ol>
<li>历史状态(history state)是一个伪状态, 其目的是记住从组合状态中退出时所处的子. 当两次进入组合状态时, 可以直接进入该子状态, 而不是再次从组合的初态开始</li>
<li>历史状态用符号<img src="https://img-blog.csdnimg.cn/a9ff2e3490374e068693b4230c1f344b.png" alt="在这里插入图片描述"><br>(浅历史状态shallow)和<img src="https://img-blog.csdnimg.cn/6b52f7b8d92e461a85dfe0c8266ee838.png" alt="在这里插入图片描述"><br>(深历史状态deep)</li>
<li>浅历史状态表示只记住最外层组合状态的历史; 而深历史状态表示可以记住任何深度的组合状态的历史</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/41d12dd63b064ed7917b560f039aea15.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="转移-transition"><a href="#转移-transition" class="headerlink" title="转移(transition)"></a>转移(transition)</h3><ol>
<li>转移是两个状态之间 的一种关系, 表示对象将在第一个状态中执行一定的动作, 并在某个特定事件发生而且某个特定的警戒条件满足时进入第二个状态</li>
<li>一般来说, 状态之间的转移是由事件触发的, 因此应在转移上标出触发事件的表达式. 如果转移上未标明事件, 则表示原状态的内部活动执行完毕后自动触发转移</li>
<li>对于一个给定状态, 最终只能产生一个转移, 所以从相同的状态出来的, 事件相同的几个转移之间的条件应该是互斥的.</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/40152db0093d4d08ae370aa97381a5f0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="事件-event"><a href="#事件-event" class="headerlink" title="事件(event)"></a>事件(event)</h3><p>事件是对一个在时间和空间上占有一定位置的, 有意义的事情的详细说明.</p>
<ol>
<li>调用事件(call event): 表示对操作的高度</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/120d90241e864303b5444edb8e1906e1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<ol>
<li>变化事件(change event): 如果一个布尔表达式的变量发生变化, 使得布尔表达式的值发生相应的变化从而满足某些条件, 则称这种事件为变化事件. 变化事件表示的是一个要被不断测试的事件. 变化事件用关键字when表示</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/305aac36ae1f437ea330ee15a533c434.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<ol>
<li>时间事件(time event): 指的是满足某一时间表达式的情况出现, 如到了某一时间点或经过了某一段时间. 时间关键字用after或when表示</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/b876debba00e4766b283d9208a680b3c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<ol>
<li><p>信号事件(signal event): 表示的是对象接收到了信号这种情况, 信号事件往往会触发状态的转移</p>
<p>“信号”就是由一个对象异步地发送并由另一个对象接收的, 已命名的对象</p>
<p>信号版型用&lt;&gt;表示, 信号之间可以有泛化关系, 形成层次结构</p>
<p>信号事件和调用事件相似, 介信号事件是异步事件, 调用事件一般是同步事件</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/d9232397f2d44c8ca242270a3c60ca80.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h3><p>动作是一个可执行的原子计算, 不可中断, 其执行时间忽略不计.</p>
<p>uml规定了两种特殊的动作: 进入动作和退出动作. 进入动作表示进入状态时执行的动作, 退出动作表示退出状态时执行的动作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">entry / setMode(onTrack)</span><br><span class="line">exit / setMode(offTrack)</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<h2 id="4-3-什么是活动图"><a href="#4-3-什么是活动图" class="headerlink" title="4.3 什么是活动图"></a>4.3 什么是活动图</h2><p>活动图可以用于描述系统的工作流程和并发行为</p>
<p>活动其实可以看作状态图的一种特殊形式, 其中一片活动结束后立即进入下一个活动(在状态图中的状态转移可能需要事件</p>
<p>的触发)</p>
<h3 id="活动"><a href="#活动" class="headerlink" title="活动"></a>活动</h3><p>活动表示某流程中的任务执行, 它可以表示某算法过程中语句的执行</p>
<p>动作状态和活动状态的区分:</p>
<ol>
<li>动作状态是原子性的, 不能被分解, 其工作所占用时间可以忽略. 动作状态的目的是”进入动作”, 然后转向另一个状态</li>
<li>活动状态是可分解的, 不是原子性的, 其工作的完成需要一定的时间, 可以把动作状态看作活动状态的特例</li>
</ol>
<h3 id="泳道"><a href="#泳道" class="headerlink" title="泳道"></a>泳道</h3><p>泳道(swimlane)是活动图中的区域划分, 系统根据每个活动的职责对所有活动进行划分, 每个泳道代表一个责任区. 每个泳道</p>
<p>并不是一一对应关系, 泳道关心的是其所代表的职责, 一个泳道可能由一个类实现, 也可能由多个类实现</p>
<p><img src="https://img-blog.csdnimg.cn/271ebe06d29643259e788226c865921c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>在活动图中, 对于同一个触发事件, 可以根据不同的触发条件转向不同的活动, 每个可能的转移是一个分支(branch)</p>
<p>两种表示方法:</p>
<ol>
<li>常规方法</li>
<li>菱形符号表示</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/a813c15fbe4e4efd875fa1367547ec24.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="分叉和汇合"><a href="#分叉和汇合" class="headerlink" title="分叉和汇合"></a>分叉和汇合</h3><p>分叉表示的是一个控制流被两个或多个控制流代替, 经过分叉后, 这些控制流是并发进行的</p>
<p>汇合正好与分叉相反, 表示两个或多个控制流 合并为一个控制流</p>
<p>如打电话的例子</p>
<p><img src="https://img-blog.csdnimg.cn/d679cee071514861b3622355a318a572.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h3><p>在活动图可以出现对象, 对象可以作为活动的输入或输出, 活动图中对象流表示活动和对象之间的关系, 如一个活动创建对象</p>
<p>(作为活动的输出)或使用对象(作为活动的输入)</p>
<p>对象流属于控制流. 如果两个活动之间有对象流, 则控制流不必重复画出</p>
<p><img src="https://img-blog.csdnimg.cn/a3404ffaa2964e849a929d8b95ea6aad.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<h2 id="4-4-活动图的用途"><a href="#4-4-活动图的用途" class="headerlink" title="4.4 活动图的用途"></a>4.4 活动图的用途</h2><p>活动图对表示并发行为很有用</p>
<p>一般活动图可以对系统的工作流程建模, 即对系统的业务建模</p>
<p>可以对具体的操作建模, 用于描述计算过程的相关细节</p>
<p>在进行用例分析时, 可以用活动图来描述用例的内部流程</p>
<p>开发人员往往用一个流程图来描述一个算法. 在UML中没有流程图的概念, 从某种意义上来说, 活动图的功能已包含了流程</p>
<p>图</p>
<h2 id="4-5-状态图和活动图的比较"><a href="#4-5-状态图和活动图的比较" class="headerlink" title="4.5 状态图和活动图的比较"></a>4.5 状态图和活动图的比较</h2><ol>
<li>状态图和活动图都是对系统的动态行为建模, 两者相似, 但也有区别</li>
<li>首先, 两者描述的重点不同. 状态图描述的是对象的状态及状态之间的转移, 而活动图描述的是从活动到活动的控制流</li>
<li>其次, 两者使用的场合不同. 如果是为了显示一个对象在其生命周期内的行为, 则使用状态图较好; 如果目的是分析用例, 理解涉及多个用例的工作流程, 或者使用多线程应用等, 则使用活动图较好</li>
<li>如果要显赫多个对象之间的交互情况, 用状态图和活动图都不合适, 这里可以用顺序图或协作图来表示</li>
</ol>
<h2 id="4-6-建模实例"><a href="#4-6-建模实例" class="headerlink" title="4.6 建模实例"></a>4.6 建模实例</h2><ol>
<li>用例图的根本意义在于明确系统的需求, 为后面的系统分析与设计奠定基础.</li>
<li>而用例文档(事件流)的作用则是对用例内部流程进行刻画, 是对用例的补充说明</li>
<li>活动图的作用其实和用例文档是异曲同工的, 只不过它们是两种不同的形式, 面向的受众也不同</li>
<li>下面采用活动图来描述课程系统中的”添加课程”用例的事件流.</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/d1f39a085fc047a5b86909b30ad4d396.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="course状态图"><a href="#course状态图" class="headerlink" title="course状态图"></a>course状态图</h4><p><img src="https://img-blog.csdnimg.cn/c4dd3685ace94bf6833db8a43b5fd03b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="第五章-类图和包"><a href="#第五章-类图和包" class="headerlink" title="第五章 类图和包"></a>第五章 类图和包</h1><h2 id="5-1-类的定义"><a href="#5-1-类的定义" class="headerlink" title="5.1 类的定义"></a>5.1 类的定义</h2><p>在UML中, 有两种图非常重要, 一种是用例图, 另一种是类图</p>
<p>类的定义: 类是具有相似结构, 行为和关系的一组对象的描述符</p>
<p><img src="https://img-blog.csdnimg.cn/d7341182ffd34d778f5c622b1e9b13a4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>类的命名分为两种形式, simple name和path name(如Util::shape, util是包名, Shape是util中的一个类)</p>
<h3 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h3><p>属性(attribute)是已被命名的类的特性, 它描述了该特性的实例可以取值的范围</p>
<p>属性描述了正被建模的事件的一些特性, 这些特性是类的所有对象所共有的</p>
<p>属性的可见性:+ - #</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+name: <span class="type">int</span>  <span class="comment">// +号表示public</span></span><br><span class="line">-age: <span class="type">int</span>   <span class="comment">// -号表示private</span></span><br><span class="line">#state: <span class="type">boolean</span>  <span class="comment">// #号表示protected</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<h3 id="类的操作"><a href="#类的操作" class="headerlink" title="类的操作"></a>类的操作</h3><p>操作(opeartion)用于修改, 检索类的属性或执行某些动作, 操作通常也称为功能, 但是它们被约束于类的内部, 只能作用到该</p>
<p>类的对象上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+display():Location</span><br><span class="line">-hide()</span><br><span class="line">#create()</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<h2 id="5-2-类之间的关系"><a href="#5-2-类之间的关系" class="headerlink" title="5.2 类之间的关系"></a>5.2 类之间的关系</h2><p>一般来说, 类之间的关系有关联, 聚集, 组合, 泛化, 依赖等</p>
<h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><p>关联(association)是模型元素间的一种主义联系, 它是对具有共同的结构特征, 行为特性, 关系和语义的链(link)的描述</p>
<p>链的概念: 链是一个实例, 就像对象是类的实例一样, 链是关联的实例, 关联表示的是类与类之间的关系, 而链表示的是对象与对象之间的关系</p>
<p>在类图中, 关联用一条把类连接在一起的实线来表示</p>
<p>一个关联可以有两个或多个关联端(association end), 每个关联端连接到一个类</p>
<p>关联也可以有方向</p>
<p>双向关联</p>
<p><img src="https://img-blog.csdnimg.cn/dd66d12edc794750af5d7af5a49540e2.png" alt="在这里插入图片描述"></p>
<p>单向关联</p>
<p><img src="https://img-blog.csdnimg.cn/902dd76f427645b6b6caa4c90f13855c.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关联关系</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="type">int</span> age</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>(1).关联名</p>
<p>可以给关联加上关联名来描述关联的作用</p>
<p><img src="https://img-blog.csdnimg.cn/a9726724455d47fdb1586e83bc42bf2a.png" alt="在这里插入图片描述"></p>
<p>如果一个关联表示的含义已经足够明确, 则无需加上关联名</p>
<p>(2). 关联的参与者</p>
<p>关联两端的类可以以某种参与者参与关联</p>
<p>参与者还具有多重性, 表示可以有多少个对象参与该关联</p>
<p>(3). 关联类</p>
<p>关联本身也有特性, 通过关联类(association class)可以进一步描述关联的属性, 操作以及其他信息</p>
<p>关联类通过一条虚线与关联连接</p>
<p><img src="https://img-blog.csdnimg.cn/ae76dbc1258442a4944061c6927f0054.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Company类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String companyName;</span><br><span class="line">    <span class="keyword">public</span> Person employee[]; <span class="comment">// 员工数组 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br><span class="line"><span class="comment">//  Person类</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String personName;</span><br><span class="line">    <span class="keyword">protected</span> Company employer; <span class="comment">// 公司老板</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类&quot;contract&quot;的代码</span></span><br><span class="line">    pubic <span class="keyword">class</span> <span class="title class_">Contract</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Double salary; <span class="comment">// 薪资</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<h3 id="聚集和组合"><a href="#聚集和组合" class="headerlink" title="聚集和组合"></a>聚集和组合</h3><p>聚集(aggregation)是一种特殊形式的关联. 如教室和桌子, 不是强绑定关系, 可以拆开独立存在</p>
<p>组合(composition)表示的也是类的整体与部分的关系, 但整体和部分具有同样的生命周期. 也就是说组合是一种特殊形式的</p>
<p>聚集. 例如: 脑袋和嘴巴的关系</p>
<p>口诀: 聚集可拆开, 组合不分割</p>
<p>设计人员根据需求分析描述来确定是使用aggregation还是compostion</p>
<h3 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h3><p>泛化(generalization)定义了一般元素和特殊元素之间的分类关系, 如果从面向对象程序设计语言的角度来说, 类与类之间的</p>
<p>泛化关系就是类与类的继承关系</p>
<p>UML中用空心三角形的连线表示泛化关系</p>
<p><img src="https://img-blog.csdnimg.cn/cfa4e2f555ec405a8abd4299b0e43726.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>假如有两个元素X和Y, 如果修改X的定义可能会导致另一个Y的定义的修改, 则称Y依赖于X</p>
<p>对于类而言, 依赖(dependency)可能由各种原因引起, 如一个类向另一个类发送消息, 或者一个类是另一个类的数据成员, 或者一个类是另一个类的操作的参数类型等</p>
<p>有时依赖关系和关联关系比较难以区分. 事实上, 如果类A和类B之间有关联关系, 那么类A和类B也就有依赖关系了. 但如果</p>
<p>两个类之间有关联关系, 只需表示出关联关系即可, 不用再表示这两个类之间有依赖关系.</p>
<p>与关联关联关系不同的是, 依赖关系本身不生成专门的实现代码</p>
<p>另外, 与泛化关系类似, 依赖关系也不仅仅限于类之间, 其它建模元素也有</p>
<h2 id="5-3-派生属性和派生关联"><a href="#5-3-派生属性和派生关联" class="headerlink" title="5.3 派生属性和派生关联"></a>5.3 派生属性和派生关联</h2><p>派生属性(derived attribute)和派生关联(derived association)是指从其它属性和关联计算推演得到的属性和关联</p>
<p>如Person类的age属性即为派生属性, 因为一个人的年龄可以从当前日期和其出生日期推算出来.</p>
<p>在类图中, 派生关联的名字前需要加一个”/“<br><img src="https://img-blog.csdnimg.cn/231177f046b946dc800fb0514c4aca4b.png" alt="在这里插入图片描述"></p>
<p>在生成代码时, 派生属性和派生关联不产生相应代码.</p>
<p>指明某些属性和关联是派生属性和派生关联有助于保障数据的一致性</p>
<h2 id="5-4-抽象类和接口"><a href="#5-4-抽象类和接口" class="headerlink" title="5.4 抽象类和接口"></a>5.4 抽象类和接口</h2><p>抽象类(abstract class)是不能直接产生实例的类, 因为抽象类中的方法往往只是一些声明, 而没有具体的实现, 因此不能对抽</p>
<p>象类实例化</p>
<p>UML中通过把类写成斜体来表示</p>
<p>接口是类的&lt;&gt;版型</p>
<p><img src="https://img-blog.csdnimg.cn/8aa45d17c70e41cfa3495c2f467a5c6e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="面试官-请你谈谈对java抽象类和接口的理解"><a href="#面试官-请你谈谈对java抽象类和接口的理解" class="headerlink" title="面试官: 请你谈谈对java抽象类和接口的理解"></a>面试官: 请你谈谈对java抽象类和接口的理解</h3><p>接口和抽象类都是继承树的上层，他们的共同点如下：</p>
<ol>
<li>都是上层的抽象层。</li>
<li>都不能被实例化</li>
<li>都能包含抽象的方法，这些抽象的方法用于描述类具备的功能，但是不提供具体的实现。<br>他们的区别如下：</li>
<li>在抽象类中可以写非抽象的方法，从而避免在子类中重复书写他们，这样可以提高代码的复用性，这是抽象类的优势；接口中只能有抽象的方法。</li>
<li>一个类只能继承一个直接父类，这个父类可以是具体的类也可是抽象类；但是一个类可以实现多个接口。<br>Java语言中类的继承是单继承原因是：当子类重写父类方法的时候，或者隐藏父类的成员变量以及静态方法的时候，JVM使用不同的绑定规则。如果一个类有多个直接的父类，那么会使绑定规则变得更复杂。为了简化软件的体系结构和绑定机制，java语言禁止多继承。<br>接口可以多继承，是因为接口中只有抽象方法，没有静态方法和非常量的属性，只有接口的实现类才会重写接口中方法。因此一个类有多个接口也不会增加JVM的绑定机制和复杂度。<br>对于已经存在的继承树，可以方便的从类中抽象出新的接口，但是从类中抽象出新的抽象类就不那么容易了，因此接口更有利于软件系统的维护和重构。</li>
</ol>
<p>图中如果Sparrow继承类Bird 类 ，Boyin继承Airplane类，Sparrow 和Boyin想使用同样的flay方法那么是没有办法实现的，因为类的继承是单继承。</p>
<h2 id="5-5-版型"><a href="#5-5-版型" class="headerlink" title="5.5 版型"></a>5.5 版型</h2><p>版型(stereotype)是UML的3种扩展机制之一, UML中的另外两种扩展机制是标记值(tagged value)和约束(constraint)</p>
<p>UML中定义了一些版型, 如包的版型有子系统等, 类的版型有接口, 参与者, 边界类, 控制类, 实体等, 当然, 用户也可以自己定义版型</p>
<h2 id="5-6-类图"><a href="#5-6-类图" class="headerlink" title="5.6 类图"></a>5.6 类图</h2><p>类加上它们之间的关系构成了类图, 类图中可以包含接口, 包, 关系等建模元素, 也可以包含对象, 链等.</p>
<p>可以说, 类图描述的类与类之间的静态关系.</p>
<p>与数据模型不同的是, 类图不仅显示了信息的结构, 同时还描述了系统的行为</p>
<h3 id="类图的抽象层次"><a href="#类图的抽象层次" class="headerlink" title="类图的抽象层次"></a>类图的抽象层次</h3><p>在软件开发的不同阶段使用的类图具有不同的抽象层次, 一般类图可分为3个层次</p>
<ol>
<li>概念层(conceptual)类图描述应用领域中的概念. 画概念层类图时, 很少考虑或不考虑实现问题, 因此, 概念层类图独立于具体的程序设计语言</li>
<li>说明层(specification)类图描述软件的接口部分, 而不是软件的实现部分</li>
<li>实现层(implementation)类图都是真正考虑类的实现问题, 提供类的实现细节的部分</li>
</ol>
<p>如圆类</p>
<p><img src="https://img-blog.csdnimg.cn/70e3676016c442f082c3d95964234429.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>概念层类图只有一个类名</p>
<p>说明层类图有类名, 属性名和方法名, 但对属性没有类型的说明, 在描述上常常采用接近现实世界的语言</p>
<p>实现层类图则对类的属性和方法都作了详细的说明, 实现层类图可能是大多数人最常用的类图.</p>
<p>可以用版型&lt;&gt;说明一个类是实现层, 用&lt;&gt;说明一个类是说明层或概念层, 当然, 也可</p>
<p>以不使用版型特别地指明</p>
<h3 id="构造类图"><a href="#构造类图" class="headerlink" title="构造类图"></a>构造类图</h3><ol>
<li><p>根据用例描述中的名词确定类的候选者. 比如, 从事件流中寻找名词或名词词组, 将性质相同的归为一类, 或者将内容正负相反的归为一类. 在事件流中, 名词可以分为4种类型: 参与者, 类, 类属性和表达式</p>
</li>
<li><p>使用CRC分析法寻找类. CRC是类(class), 职责(responsibility)和协作(collaboration)的简称. CRC分析法根据类所要扮演的职责来确定类</p>
</li>
<li><p>根据边界类, 控制类和实体类的划分来帮助发现系统中的类. 对领域进行分析, 或者利用已有的领域分析结果得到类</p>
</li>
<li><p>参考设计模式来确定类. 如工厂模式</p>
</li>
<li><p>根据某些软件开发过程提供的指导原由进行寻找类的工作</p>
</li>
</ol>
<p>构造类图时不要过早陷入实现细节, 就该根据项目开发的不同阶段, 采用不同层次的类图</p>
<p>如果处于分析阶段, 应画概念层类图; 当开始着手软件设计时, 应画说明层类图;当考察某个特定的实现技术时, 则应画实现层类图</p>
<h2 id="5-7-包的基本概念"><a href="#5-7-包的基本概念" class="headerlink" title="5.7 包的基本概念"></a>5.7 包的基本概念</h2><p>包就像一个容器, 可用于组织模型中的相关元素以使其更易于理解</p>
<p>包中可以包含其它建模元素, 如类, 接口, 构件, 节点, 用例, 包等</p>
<p>包中元素也可进行可见性控制</p>
<p>+表示public -表示private #表示protected</p>
<p>AWT包中有三个元素:</p>
<ol>
<li>其中window的可见性为public, 表示任何导入AWT包的包中, 都可以引用window元素</li>
<li>Form可见性为protected, 表示只有AWT包的子包才可以引用Form元素</li>
<li>EvenHandler的可见性为private, 表示只有在AWT包中才可以引用EventHandler元素</li>
</ol>
<p>对包的命名有两种方式, 简单包名和路径包名. 如Sensors::Vision</p>
<p>下图的依赖关系的版型都是&lt;&gt;, 表示源包会存取目的包中的内容, 同时目的包中的内容是加到源包的名字空间的,</p>
<p>这样引用目的包中的内容就不需要加包名限定, 直接用目的包中的元素名字即可</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-x855TN2y-1631930294569)(image-20210615165500840.png)]</p>
<p>在数据建模中, 用包表示模式和域, 在数据模型和对象模型之间转换是以包为单位进行的</p>
<p>在Web建模中, 包可以表示某一虚拟目录(virtual directory), 在该目录下的所有Web元素都在这个包中</p>
<h2 id="5-8-建模实例"><a href="#5-8-建模实例" class="headerlink" title="5.8 建模实例"></a>5.8 建模实例</h2><p>以课程为例, 介绍采用StarUml创建Course类的过程</p>
<p><img src="https://img-blog.csdnimg.cn/94732424de41471fbf7e40f46b99f4de.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="第六章-交互图-用例的实现"><a href="#第六章-交互图-用例的实现" class="headerlink" title="第六章 交互图: 用例的实现"></a>第六章 交互图: 用例的实现</h1><h2 id="6-1-交互图概述"><a href="#6-1-交互图概述" class="headerlink" title="6.1 交互图概述"></a>6.1 交互图概述</h2><ol>
<li><p>在UML中, 用例的实现用交互图来指定和说明</p>
</li>
<li><p>交互图通过显示对象之间的关系和对象之间处理的消息来对系统的动态特性建模</p>
</li>
<li><p>交互图包括顺序图和协作图两种形式</p>
</li>
<li><p>顺序图养生描述对象按照时间顺序的消息交换, 而协作图着重描述系统成分如何协同工作</p>
</li>
<li><p>顺序图和协作图从不同的角度表达了系统中的交互和行为, 它们之间可以相互转化</p>
</li>
<li><p>交互图和类图可以相互补充, 类图对类的描述比较充分, 但对对象之间的消息交互情况的表达不够详细, 而交互图虽不考虑系统中的所有类及对象, 但可以表示系统中某几个对象之间的交互</p>
</li>
</ol>
<h2 id="6-2-顺序图"><a href="#6-2-顺序图" class="headerlink" title="6.2 顺序图"></a>6.2 顺序图</h2><p>顺序图也称时序图. 顺序图是显示对象之间的交互的图, 这些对象是按时间顺序排列的.</p>
<p>顺序图组成:</p>
<ol>
<li>对象:表示为一个矩形, 对象名称标有下划线</li>
<li>消息: 用有标记的箭头表示</li>
<li>生命线: 用虚线表示</li>
<li>控制焦点: 用极窄矩形表示<br><img src="https://img-blog.csdnimg.cn/dd72380f9c934254827b7a6ae678d62f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
</ol>
<p>顺序图在纵向是时间轴, 横向轴代表在协作中各独立对象的类元参与者. 当对象存在时, 生命线用一条纵向虚线表示, 当对象</p>
<p>的过程处于激活状态时, 生命线是双道线</p>
<p>消息用从一个对象的生命线到鼍一个对象的生命线的箭头表示</p>
<p>一般习惯把表示的对象放在图的两侧, 如表示人的参与者放在最左边, 表示系统的参与者放在最右边</p>
<p>顺序图中对象命名的3种方式</p>
<p>控制焦点是顺序图中表示时间段的符号.6.3 顺序图中消息</p>
<h3 id="调用消息"><a href="#调用消息" class="headerlink" title="调用消息"></a>调用消息</h3><p>调用消息的发送者把控制传递给消息的接收者, 然后停止活动, 等待消息接收者放弃或返回控制. 调用消息可以用来表示同步的含义</p>
<p><img src="https://img-blog.csdnimg.cn/b9c63a6f83064125a15a3f5ab9dd0bd6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="异步消息"><a href="#异步消息" class="headerlink" title="异步消息"></a>异步消息</h3><p>异步消息的发送者通过消息把信号传递给消息的接收者, 然后继续自己的, 不等待接收者返回消息或控制</p>
<p><img src="https://img-blog.csdnimg.cn/456e7255ed0b4722a097f76a10f5af13.png" alt="在这里插入图片描述"></p>
<h3 id="返回消息"><a href="#返回消息" class="headerlink" title="返回消息"></a>返回消息</h3><p>返回消息表示从过程调用返回</p>
<p>如果是从过程调用返回, 则返回消息是隐含的, 故返回消息可以不用画出来, 对于非过程调用, 如果有返回消息, 必须明确表示出来</p>
<p><img src="https://img-blog.csdnimg.cn/e1de8cb5deb94cbb965334f739a42023.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="阻止消息和超时消息-不常用"><a href="#阻止消息和超时消息-不常用" class="headerlink" title="阻止消息和超时消息(不常用)"></a>阻止消息和超时消息(不常用)</h3><p>阻止消息是指消息发送者发出消息给消息接收者, 如果接收者无法立即接收消息, 则发送者放弃这个消息</p>
<p>超时消息是指消息发送者发送消息给接收者并按指定时间等待. 如果接收者无法在指定时间内接收消息, 则发送者放弃这个消息</p>
<h2 id="6-4-协作图"><a href="#6-4-协作图" class="headerlink" title="6.4 协作图"></a>6.4 协作图</h2><p><a target="_blank" rel="noopener" href="https://img-blog.csdnimg.cn/6c93557997f24604b1729c934e216758.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16">在这里插入图片描述</a></p>
<p>协作图是用于描述系统行为是如何由各个部分协作实现的图, 协作图包括的建模元素有对象(包括参与者实例, 多对象, 主动</p>
<p>对象等), 消息, 链等</p>
<p>协作图由参与者, 对象, 连接和消息等基本元素组成</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>表示参与协作的对象</p>
<p>在协作图中, 多对象指的是由多个对象组成的对象集合, 一般这些对象是属于同一个类的</p>
<p>当需要把消息同时发送给多个对象而不是对象的时候, 就要使用多对象这概念.</p>
<p>协作图的多对象用多个方框的重叠表示, 而顺序图的多对象显示出来和单对象是一样的</p>
<h3 id="对象关联"><a href="#对象关联" class="headerlink" title="对象关联"></a>对象关联</h3><p>对象关联连接两个对象, 表示两者间的关联, 也称为链</p>
<h3 id="消息-1"><a href="#消息-1" class="headerlink" title="消息"></a>消息</h3><p>协作图的消息定义与顺序图的消息是完全一样的</p>
<h3 id="消息序号"><a href="#消息序号" class="headerlink" title="消息序号"></a>消息序号</h3><p>消息序号是消息的一部分, 序号表明消息传递的先后顺序</p>
<h2 id="6-5-顺序图和协作图的比较"><a href="#6-5-顺序图和协作图的比较" class="headerlink" title="6.5 顺序图和协作图的比较"></a>6.5 顺序图和协作图的比较</h2><ol>
<li>顺序图强调是消息的时间顺序, 而协作图强调的是参与交互的对象的组织</li>
<li>顺序图在表示表示算法, 对象的生命其, 具有多线程特征的对象等方面更具有优势, 协作图在表示并发控制方面更有优势</li>
<li>顺序图中不能表示对象与对象之间的连接(即”链”), 多对象和主动对象也不能直接显示出来, 协作图则可以表示</li>
<li>协作图不能表示生命线的分叉(fork), 而顺序图可以表示出来</li>
</ol>
<h2 id="6-6-问题分析"><a href="#6-6-问题分析" class="headerlink" title="6.6 问题分析"></a>6.6 问题分析</h2><p>有兴趣的读者可以参考书籍page127, 这里不再赘述</p>
<h2 id="6-7-建模实例"><a href="#6-7-建模实例" class="headerlink" title="6.7 建模实例"></a>6.7 建模实例</h2><h3 id="顺序图-用例-用户买票"><a href="#顺序图-用例-用户买票" class="headerlink" title="顺序图(用例: 用户买票)"></a>顺序图(用例: 用户买票)</h3><p><img src="https://img-blog.csdnimg.cn/3d022ee2d7cc422da9d2c22d61cde8e7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="第七章-数据建模"><a href="#第七章-数据建模" class="headerlink" title="第七章 数据建模"></a>第七章 数据建模</h1><h2 id="7-1-数据建模概述"><a href="#7-1-数据建模概述" class="headerlink" title="7.1 数据建模概述"></a>7.1 数据建模概述</h2><ol>
<li>E-R图指以实体, 关系, 属性3个基本概念分手数据的基本结构, 从而描述静态数据结构的概念模式.</li>
<li>E-R的问题是只能着眼于数据, 而不能对行为建模, 如触发器(trigger), 存储过程(stored procedure)等建模</li>
<li>UML描述能力更强, UML的类图可以看作是E-R图的扩充.</li>
<li>可以用的类图描述数据为模式(database schema), 以及数据库表, 用类的操作来描述触发器和存储过程</li>
</ol>
<h2 id="7-2-数据库设计的基本过程"><a href="#7-2-数据库设计的基本过程" class="headerlink" title="7.2 数据库设计的基本过程"></a>7.2 数据库设计的基本过程</h2><p>数据库设计主要涉及三阶段,即概念设计, 逻辑设计和物理设计</p>
<ol>
<li><p>概念设计阶段是把用户的信息要求统一到一个整体逻辑结构中, 此结构能表达用户的要求, 且独立于任何数据库管理系统(DBMS)软件和硬件</p>
</li>
<li><p>逻辑结构设计阶段的任务是把概念设计阶段得到的结果转换为与先用的DBMS所支持的数据模型相符的逻辑结构</p>
</li>
<li><p>物理设计阶段的任何是对给定的数据结构模型选取一个最符合应用要求的物理结构. 数据库物理结构包括数据库的存储记录格式, 存储记录安排, 存取方法等.</p>
</li>
</ol>
<p>数据库中的概念 版型 所应用的UML元素</p>
<p>数据库建模中常用的版型</p>
<p><img src="https://img-blog.csdnimg.cn/ae13e90ac0b0405f82c5906fe537397f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="7-3-数据库设计步骤"><a href="#7-3-数据库设计步骤" class="headerlink" title="7.3 数据库设计步骤"></a>7.3 数据库设计步骤</h2><p>有兴趣的读者可以查看书籍Page141, 这里不再赘述</p>
<h2 id="7-4-对象模型和数据模型间的转换"><a href="#7-4-对象模型和数据模型间的转换" class="headerlink" title="7.4 对象模型和数据模型间的转换"></a>7.4 对象模型和数据模型间的转换</h2><p>有兴趣的读者可以查看书籍Page141, 这里不再赘述</p>
<h1 id="第八章-构件图和双向工程"><a href="#第八章-构件图和双向工程" class="headerlink" title="第八章 构件图和双向工程"></a>第八章 构件图和双向工程</h1><h2 id="8-1-什么是构件图"><a href="#8-1-什么是构件图" class="headerlink" title="8.1 什么是构件图"></a>8.1 什么是构件图</h2><p>构件是系统遵从一一组接口且提供其实现的物理的, 可替换的部分.</p>
<p>构件图则显示一级构件及它们之间的相互关系, 包括编译, 链接或执行时构件之间的依赖关系</p>
<p>如图是一个构件图的例子, 表示.html文件 .exe文件和.dll文件这些构件之间的相互依赖关系</p>
<p><img src="https://img-blog.csdnimg.cn/9f30713b1b224a3d95c859b16fc13326.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>构件就是一个实际文件, 它可以有以下几种类型:</p>
<ol>
<li>构件部署(deployment component), 如.dll文件, .exe文件等</li>
<li>工作产品构件(work product component), 如源代码文件, 数据文件, 这些构件可以用来产生部署构件</li>
<li>执行构件(execution component), 也就是系统执行后得到的构件</li>
</ol>
<h2 id="8-2-构件图的作用"><a href="#8-2-构件图的作用" class="headerlink" title="8.2 构件图的作用"></a>8.2 构件图的作用</h2><p>构件图可以对以下几个方面建模:</p>
<ol>
<li>对源代码文件之间的相互关系建模</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/bbc5963ef9ac4fd49aa26ad4f6764d93.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<ol>
<li>对可执行文件的相关关系建模</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/c9cf5a02ac55437a8ca70822fa99f410.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="8-3-构件图的工具支持"><a href="#8-3-构件图的工具支持" class="headerlink" title="8.3 构件图的工具支持"></a>8.3 构件图的工具支持</h2><ol>
<li><p>正向工程</p>
<p>正向工程就是根据模型来产生源代码, 当然得到源代码后再调用相应的编译器即可得到可执行代码</p>
</li>
<li><p>通过代码来得到模型</p>
</li>
</ol>
<p>具体详情实现这里不再赘述, 有兴趣的读者可以查阅书籍P158即可.</p>
<h1 id="第九章-部署图"><a href="#第九章-部署图" class="headerlink" title="第九章 部署图"></a>第九章 部署图</h1><h2 id="9-1-什么是部署图"><a href="#9-1-什么是部署图" class="headerlink" title="9.1 什么是部署图"></a>9.1 什么是部署图</h2><ol>
<li>部署图也称配置图或实施图, 是对OO系统物理方面建模的两个图之一(另一个图是构件图)</li>
<li>部署图可以用来显示系统中计算节点的拓扑结构和通信路径与节点上运行的软构件等</li>
<li>一个系统模型可得一个部署图, 部署图常常用于理解分布式系统</li>
</ol>
<h2 id="9-2-部署图中基本概念"><a href="#9-2-部署图中基本概念" class="headerlink" title="9.2 部署图中基本概念"></a>9.2 部署图中基本概念</h2><p>部署图有两个巧夺天工概念: 节点和连接</p>
<h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><ol>
<li>节点是存在于运行时的, 代表计算资源的物理元素, 节点一般才具有一些内存, 而且学常具有处理能力</li>
<li>节点可以代表一个物理设备及运行该设备的软件系统, 如UNIX主机, 传感器等.</li>
<li>节点之间的连线表示系统之间进行交互的通信路径, 这个通信路径称为连接(connection)</li>
<li>部署图中的节点分为两种类型, 即处理机(Processor)和设备(Modem)</li>
<li>处理机是可以执行程序的硬件构件, 在部署图中, 可以说明处理机中有哪些进程, 进程的优先级与进程调度方式等</li>
<li>设备是无计算能力的硬件结构, 如调制调解器, 终端等.</li>
</ol>
<h2 id="9-3-部署图的例子"><a href="#9-3-部署图的例子" class="headerlink" title="9.3 部署图的例子"></a>9.3 部署图的例子</h2><h3 id="微服务部署图-购物网站"><a href="#微服务部署图-购物网站" class="headerlink" title="微服务部署图(购物网站)"></a>微服务部署图(购物网站)</h3><p><img src="https://img-blog.csdnimg.cn/876625965ec84ff7880d95c00e5cc202.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="pc-外设-及ISP的连接部署图"><a href="#pc-外设-及ISP的连接部署图" class="headerlink" title="pc, 外设, 及ISP的连接部署图"></a>pc, 外设, 及ISP的连接部署图</h3><p><img src="https://img-blog.csdnimg.cn/8fc5b66294424bb0ade0adba70d9b29b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="9-4-建模实例"><a href="#9-4-建模实例" class="headerlink" title="9.4 建模实例"></a>9.4 建模实例</h2><p><img src="https://img-blog.csdnimg.cn/5b212e0076da440e880fc5c76b4dd54c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="第十章-建模实例分析"><a href="#第十章-建模实例分析" class="headerlink" title="第十章 建模实例分析"></a>第十章 建模实例分析</h1><h2 id="10-1-引言"><a href="#10-1-引言" class="headerlink" title="10.1 引言"></a>10.1 引言</h2><p>有兴趣的读者可以查看书籍Page174, 此处仅提供一张类图</p>
<p><img src="https://img-blog.csdnimg.cn/286115e4bdd5470d9676a6969cf72e17.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR6Lef5L2g5ou85ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="最后-祝各位同学金榜题名-事业有成"><a href="#最后-祝各位同学金榜题名-事业有成" class="headerlink" title="最后, 祝各位同学金榜题名, 事业有成 !"></a>最后, 祝各位同学金榜题名, 事业有成 !</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.hegra.top/">Hegra</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.hegra.top/2023/03/04/UML%E5%BB%BA%E6%A8%A1/">http://blog.hegra.top/2023/03/04/UML%E5%BB%BA%E6%A8%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.hegra.top" target="_blank">Hegra's world</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://edu-727.oss-cn-nanjing.aliyuncs.com/Other%20Pictures/ec43126fgy1hb0l7n507lj22dq1feu0x.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css" media="print" onload="this.media='all'"><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/04/FavoriteMusic/"><img class="prev-cover" src="https://edu-727.oss-cn-nanjing.aliyuncs.com/Other%20Pictures/91384059_p0.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">最爱的音乐风格</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/04/lambd%E8%A1%A8%E8%BE%BE%E5%BC%8F/"><img class="next-cover" src="https://edu-727.oss-cn-nanjing.aliyuncs.com/Other%20Pictures/94945362_p0_master1200.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Lambda表达式</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://edu-727.oss-cn-nanjing.aliyuncs.com/%E7%BB%B4%E5%B0%BC.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Hegra</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Hegra-727"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Hegra-727" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:Hegra727@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0"><span class="toc-text">第一章 面向对象技术概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%8D%B1%E6%9C%BA%E5%92%8C%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B"><span class="toc-text">软件危机和软件工程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A4%8D%E6%9D%82%E6%80%A7%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-text">控制软件系统复杂性的基本方法:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%86%E8%A7%A3"><span class="toc-text">(1)分解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8A%BD%E8%B1%A1"><span class="toc-text">(2) 抽象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-text">(3) 模块化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BF%A1%E6%81%AF%E9%9A%90%E8%94%BD"><span class="toc-text">(4)信息隐蔽</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AE%9E%E4%BE%8B"><span class="toc-text">对象和实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-text">类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-text">封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF"><span class="toc-text">消息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-UML%E6%A6%82%E8%BF%B0"><span class="toc-text">第二章 UML概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UML%E7%9A%84%E6%9E%84%E6%88%90"><span class="toc-text">UML的构成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%9E%84%E9%80%A0%E5%9D%97"><span class="toc-text">1. 基本构造块:</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB-%E4%BE%9D%E8%B5%96dependency-%E5%85%B3%E8%81%94association-%E6%B3%9B%E5%8C%96generalization-%E5%AE%9E%E7%8E%B0realization"><span class="toc-text">关系(依赖dependency, 关联association, 泛化generalization, 实现realization)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE-diagram"><span class="toc-text">图(diagram)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8B%E7%89%A9-thing"><span class="toc-text">事物(thing):</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%A7%84%E5%88%99-rule"><span class="toc-text">2. 规则(rule)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%85%AC%E5%85%B1%E6%9C%BA%E5%88%B6-common-mechanism"><span class="toc-text">3. 公共机制(common mechanism)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BA%94%E4%B8%AA%E8%AF%AD%E4%B9%89%E8%A7%84%E5%88%99"><span class="toc-text">4. 五个语义规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%80%9A%E7%94%A8%E6%9C%BA%E5%88%B6"><span class="toc-text">5.通用机制:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UML%E7%9A%84%E8%A7%86%E5%9B%BE"><span class="toc-text">UML的视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UMl%E7%9A%84%E5%BA%94%E7%94%A8%E9%A2%86%E5%9F%9F"><span class="toc-text">UMl的应用领域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%94%A8%E4%BE%8B%E5%9B%BE-%E5%BB%BA%E6%A8%A1%E7%9A%84%E5%BC%80%E5%A7%8B"><span class="toc-text">第三章 用例图: 建模的开始</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BB%BA%E6%A8%A1"><span class="toc-text">什么是建模</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B%E5%9B%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">用例图基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E4%B8%8E%E8%80%85%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">参与者的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E5%92%8C%E7%A1%AE%E5%AE%9A%E5%8F%82%E4%B8%8E%E8%80%85"><span class="toc-text">寻找和确定参与者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E7%82%B9"><span class="toc-text">检查点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E4%B8%8E%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">参与者之间的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B"><span class="toc-text">用例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E7%94%A8%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-text">3.6 用例分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B%E7%9A%84%E7%B2%92%E5%BA%A6"><span class="toc-text">用例的粒度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="toc-text">用例的获取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E5%92%8C%E6%AD%A5%E9%AA%A4%E7%9A%84%E8%AF%AF%E5%8C%BA"><span class="toc-text">目标和步骤的误区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B%E7%B2%92%E5%BA%A6%E7%9A%84%E8%AF%AF%E5%8C%BA"><span class="toc-text">用例粒度的误区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E7%94%A8%E4%BE%8B"><span class="toc-text">业务用例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E7%94%A8%E4%BE%8B%E5%AE%9E%E7%8E%B0"><span class="toc-text">业务用例实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%94%A8%E4%BE%8B"><span class="toc-text">系统用例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B%E5%AE%9E%E7%8E%B0"><span class="toc-text">用例实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E7%94%A8%E4%BE%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">3.7 用例之间的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%8C%96%E5%85%B3%E7%B3%BB-generalization"><span class="toc-text">泛化关系(generalization)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E5%90%AB%E5%85%B3%E7%B3%BB-include"><span class="toc-text">包含关系(include)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%85%B3%E7%B3%BB-extend"><span class="toc-text">扩展关系(extend)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B%E7%9A%84%E6%B3%9B%E5%8C%96-%E5%8C%85%E5%90%AB-%E6%89%A9%E5%B1%95%E5%85%B3%E7%B3%BB%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">用例的泛化, 包含, 扩展关系的比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-%E7%94%A8%E4%BE%8B%E5%9B%BE"><span class="toc-text">3.8 用例图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-%E7%94%A8%E4%BE%8B%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="toc-text">3.9 用例的描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-10-%E5%AF%BB%E6%89%BE%E7%94%A8%E4%BE%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">3.10 寻找用例的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-11-%E5%BB%BA%E6%A8%A1%E5%AE%9E%E4%BE%8B"><span class="toc-text">3.11 建模实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%8A%B6%E6%80%81%E5%9B%BE%E5%92%8C%E6%B4%BB%E5%8A%A8%E5%9B%BE"><span class="toc-text">第四章 状态图和活动图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E4%BB%80%E4%B9%88%E6%98%AF%E7%8A%B6%E6%80%81%E5%9B%BE"><span class="toc-text">4.1什么是状态图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E7%8A%B6%E6%80%81%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">4.2 状态图的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81"><span class="toc-text">状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%8A%B6%E6%80%81%E5%92%8C%E5%AD%90%E7%8A%B6%E6%80%81"><span class="toc-text">组合状态和子状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2%E7%8A%B6%E6%80%81"><span class="toc-text">历史状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB-transition"><span class="toc-text">转移(transition)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6-event"><span class="toc-text">事件(event)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E4%BD%9C"><span class="toc-text">动作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B4%BB%E5%8A%A8%E5%9B%BE"><span class="toc-text">4.3 什么是活动图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8"><span class="toc-text">活动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%B3%E9%81%93"><span class="toc-text">泳道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF"><span class="toc-text">分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8F%89%E5%92%8C%E6%B1%87%E5%90%88"><span class="toc-text">分叉和汇合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B5%81"><span class="toc-text">对象流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E6%B4%BB%E5%8A%A8%E5%9B%BE%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-text">4.4 活动图的用途</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E7%8A%B6%E6%80%81%E5%9B%BE%E5%92%8C%E6%B4%BB%E5%8A%A8%E5%9B%BE%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">4.5 状态图和活动图的比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E5%BB%BA%E6%A8%A1%E5%AE%9E%E4%BE%8B"><span class="toc-text">4.6 建模实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#course%E7%8A%B6%E6%80%81%E5%9B%BE"><span class="toc-text">course状态图</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%B1%BB%E5%9B%BE%E5%92%8C%E5%8C%85"><span class="toc-text">第五章 类图和包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">5.1 类的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">类的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">类的操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">5.2 类之间的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94"><span class="toc-text">关联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E9%9B%86%E5%92%8C%E7%BB%84%E5%90%88"><span class="toc-text">聚集和组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%8C%96"><span class="toc-text">泛化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96"><span class="toc-text">依赖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E6%B4%BE%E7%94%9F%E5%B1%9E%E6%80%A7%E5%92%8C%E6%B4%BE%E7%94%9F%E5%85%B3%E8%81%94"><span class="toc-text">5.3 派生属性和派生关联</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-text">5.4 抽象类和接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98-%E8%AF%B7%E4%BD%A0%E8%B0%88%E8%B0%88%E5%AF%B9java%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">面试官: 请你谈谈对java抽象类和接口的理解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E7%89%88%E5%9E%8B"><span class="toc-text">5.5 版型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-%E7%B1%BB%E5%9B%BE"><span class="toc-text">5.6 类图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9B%BE%E7%9A%84%E6%8A%BD%E8%B1%A1%E5%B1%82%E6%AC%A1"><span class="toc-text">类图的抽象层次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E7%B1%BB%E5%9B%BE"><span class="toc-text">构造类图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-%E5%8C%85%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">5.7 包的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8-%E5%BB%BA%E6%A8%A1%E5%AE%9E%E4%BE%8B"><span class="toc-text">5.8 建模实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E4%BA%A4%E4%BA%92%E5%9B%BE-%E7%94%A8%E4%BE%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">第六章 交互图: 用例的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E4%BA%A4%E4%BA%92%E5%9B%BE%E6%A6%82%E8%BF%B0"><span class="toc-text">6.1 交互图概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E9%A1%BA%E5%BA%8F%E5%9B%BE"><span class="toc-text">6.2 顺序图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%B6%88%E6%81%AF"><span class="toc-text">调用消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF"><span class="toc-text">异步消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E6%B6%88%E6%81%AF"><span class="toc-text">返回消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2%E6%B6%88%E6%81%AF%E5%92%8C%E8%B6%85%E6%97%B6%E6%B6%88%E6%81%AF-%E4%B8%8D%E5%B8%B8%E7%94%A8"><span class="toc-text">阻止消息和超时消息(不常用)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E5%8D%8F%E4%BD%9C%E5%9B%BE"><span class="toc-text">6.4 协作图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-text">对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94"><span class="toc-text">对象关联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF-1"><span class="toc-text">消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%BA%8F%E5%8F%B7"><span class="toc-text">消息序号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-%E9%A1%BA%E5%BA%8F%E5%9B%BE%E5%92%8C%E5%8D%8F%E4%BD%9C%E5%9B%BE%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">6.5 顺序图和协作图的比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-text">6.6 问题分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-%E5%BB%BA%E6%A8%A1%E5%AE%9E%E4%BE%8B"><span class="toc-text">6.7 建模实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%9B%BE-%E7%94%A8%E4%BE%8B-%E7%94%A8%E6%88%B7%E4%B9%B0%E7%A5%A8"><span class="toc-text">顺序图(用例: 用户买票)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1"><span class="toc-text">第七章 数据建模</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%E6%A6%82%E8%BF%B0"><span class="toc-text">7.1 数据建模概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B"><span class="toc-text">7.2 数据库设计的基本过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E6%AD%A5%E9%AA%A4"><span class="toc-text">7.3 数据库设计步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">7.4 对象模型和数据模型间的转换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%9E%84%E4%BB%B6%E5%9B%BE%E5%92%8C%E5%8F%8C%E5%90%91%E5%B7%A5%E7%A8%8B"><span class="toc-text">第八章 构件图和双向工程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%9E%84%E4%BB%B6%E5%9B%BE"><span class="toc-text">8.1 什么是构件图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E6%9E%84%E4%BB%B6%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">8.2 构件图的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E6%9E%84%E4%BB%B6%E5%9B%BE%E7%9A%84%E5%B7%A5%E5%85%B7%E6%94%AF%E6%8C%81"><span class="toc-text">8.3 构件图的工具支持</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E9%83%A8%E7%BD%B2%E5%9B%BE"><span class="toc-text">第九章 部署图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%83%A8%E7%BD%B2%E5%9B%BE"><span class="toc-text">9.1 什么是部署图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E9%83%A8%E7%BD%B2%E5%9B%BE%E4%B8%AD%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">9.2 部署图中基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9"><span class="toc-text">节点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-%E9%83%A8%E7%BD%B2%E5%9B%BE%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-text">9.3 部署图的例子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E5%9B%BE-%E8%B4%AD%E7%89%A9%E7%BD%91%E7%AB%99"><span class="toc-text">微服务部署图(购物网站)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pc-%E5%A4%96%E8%AE%BE-%E5%8F%8AISP%E7%9A%84%E8%BF%9E%E6%8E%A5%E9%83%A8%E7%BD%B2%E5%9B%BE"><span class="toc-text">pc, 外设, 及ISP的连接部署图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-%E5%BB%BA%E6%A8%A1%E5%AE%9E%E4%BE%8B"><span class="toc-text">9.4 建模实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E5%BB%BA%E6%A8%A1%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-text">第十章 建模实例分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E5%BC%95%E8%A8%80"><span class="toc-text">10.1 引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%90%8E-%E7%A5%9D%E5%90%84%E4%BD%8D%E5%90%8C%E5%AD%A6%E9%87%91%E6%A6%9C%E9%A2%98%E5%90%8D-%E4%BA%8B%E4%B8%9A%E6%9C%89%E6%88%90"><span class="toc-text">最后, 祝各位同学金榜题名, 事业有成 !</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.hegra.top/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.hegra.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>